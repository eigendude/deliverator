#!/usr/bin/env python
################################################################################
#
#      Copyright (C) 2016 juztamau5
#      Software License Agreement (MIT License)
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#      The above copyright notice and this permission notice shall be included
#      in all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#  THE SOFTWARE.
#
################################################################################

from deliverator_msgs.msg import WiFiInterfaceData
from deliverator_msgs.msg import WiFiScanData
from deliverator_msgs.msg import WiFiStationData
from deliverator_msgs.srv import CheckIsWireless
from deliverator_msgs.srv import StartScan
from deliverator_msgs.srv import EndScan
import rospy

import subprocess

NODE_NAME          = 'wifi_manager_py'
WIFI_SERVICE       = 'check_is_wireless'
START_SCAN_SERVICE = 'start_wifi_scan'
END_SCAN_SERVICE   = 'end_wifi_scan'
TOPIC_NAME         = 'wifi_status'


class line_matcher:
    def __init__(self, regexp, handler):
        self.regexp  = re.compile(regexp)
        self.handler = handler


def handle_new_network(line, result, networks):
    # group(1) is the mac address
    networks.append({})
    networks[-1]['Address'] = result.group(1)

def handle_essid(line, result, networks):
    # group(1) is the essid name
    networks[-1]['ESSID'] = result.group(1)

def handle_quality(line, result, networks):
    # group(1) is the quality value
    # group(2) is probably always 100
    networks[-1]['Quality'] = result.group(1) + '/' + result.group(2)

def handle_unknown(line, result, networks):
    # group(1) is the key, group(2) is the rest of the line
    networks[-1][result.group(1)] = result.group(2)

class WiFiManager:
    def __init__(self):
        self._scanInterfaces = [ ]

    def checkIsWireless(self, req):
        return req.device and req.device[0] == 'w' # TODO

    def startScan(self, req):
        if req.interface not in self._scanInterfaces:
            self._scanInterfaces.append(req.interface)

    def endScan(self, req):
        if req.interface in self._scanInterfaces:
            self._scanInterfaces.remove(req.interface)

    def getScan(self):
        scanMsg = WiFiScanData()
        for interface in self._scanInterfaces:
            interfaceMsg = WiFiInterfaceData()

            proc = subprocess.Popen(['iw', 'dev', interface, 'scan'], stdout=subprocess.PIPE)
            stdout, stderr =  proc.communicate()

            lines = stdout.decode('utf-8').split('\n')

            networks = []
            matchers = []

            # catch the line 'Cell ## - Address: XX:YY:ZZ:AA:BB:CC'
            matchers.append(line_matcher(r'\s+Cell \d+ - Address: (\S+)', handle_new_network))

            # catch the line 'ESSID:"network name"
            matchers.append(line_matcher(r'\s+ESSID:"([^"]+)"', handle_essid))

            # catch the line 'Quality:X/Y Signal level:X dBm Noise level:Y dBm'
            matchers.append(line_matcher(r'\s+Quality:(\d+)/(\d+)', handle_quality))

            # catch the line 'Quality=X/Y  Signal level=X dBm'
            matchers.append(line_matcher(r'\s+Quality=(\d+)/(\d+)', handle_quality))

            # catch any other line that looks like this:
            # Key:value
            matchers.append(line_matcher(r'\s+([^:]+):(.+)', handle_unknown))

            # read each line of output, testing against the matches above
            # in that order (so that the key:value matcher will be tried last)
            for line in lines:
                for m in matchers:
                    result = m.regexp.match(line)
                    if result:
                        m.handler(line, result, networks)
                        break

            for network in networks:
                stationMsg = WiFiStationData()
                stationMsg.mac_address = network['Address']
                stationMsg.ssid = network['ESSID']
                stationMsg.channel = 0 # TODO
                stationMsg.dbm = 0.0 # TODO
                stationMsg.percent = 0 # TODO
                stationMsg.age_ms = 0 # TODO
                interfaceMsg.stations.append(station)

            if len(interfaceMsg.stations) > 0:
                interfaceMsg.name = interface
                scanMsg.interfaces.append(interfaceMsg)

        return scanMsg

def main():
    rospy.init_node(NODE_NAME, log_level=rospy.DEBUG)

    wifiManager = WiFiManager()

    services = [
        rospy.Service(WIFI_SERVICE, CheckIsWireless, wifiManager.checkIsWireless),
        rospy.Service(START_SCAN_SERVICE, StartScan, wifiManager.startScan),
        rospy.Service(END_SCAN_SERVICE, EndScan, wifiManager.endScan)
    ]

    pub = rospy.Publisher(TOPIC_NAME, WiFiScanData, queue_size=1)

    rate = rospy.Rate(1) # Hz
    while not rospy.is_shutdown():
        msg = wifiManager.getScan()
        if msg:
            pub.publish(msg)

        rate.sleep()

if __name__ == '__main__':
    main()
