#!/usr/bin/env python
################################################################################
#
#      Copyright (C) 2016 juztamau5
#      Software License Agreement (MIT License)
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#      The above copyright notice and this permission notice shall be included
#      in all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#  THE SOFTWARE.
#
################################################################################

from deliverator_msgs.msg import WiFiScanData
from deliverator_msgs.msg import WiFiStationData
from deliverator_msgs.srv import CheckIsWireless
from deliverator_msgs.srv import StartScan
from deliverator_msgs.srv import EndScan
import rospy
import std_msgs.msg

import re
import subprocess

NODE_NAME          = 'wifi_manager_py'
WIFI_SERVICE       = 'check_is_wireless'
START_SCAN_SERVICE = 'start_wifi_scan'
END_SCAN_SERVICE   = 'end_wifi_scan'
TOPIC_NAME         = 'wifi_status'


class line_matcher:
    def __init__(self, regexp, handler):
        self.regexp  = re.compile(regexp)
        self.handler = handler


def handle_new_network(line, result, networks):
    networks.append({})
    # group(1) is the mac address
    networks[-1]['Address'] = [int(b, 16) for b in result.group(1).split(':')]

def handle_ssid(line, result, networks):
    # group(1) is the ssid name
    networks[-1]['SSID'] = result.group(1).encode('ascii', 'ignore')

def handle_freq(line, result, networks):
    # group(1) is the frequency in MHz
    networks[-1]['channel'] = int(result.group(1)) # TODO

def handle_signal(line, result, networks):
    # group(1) is the signal strength (dBm)
    networks[-1]['signal'] = float(result.group(1))

def handle_last_seen(line, result, networks):
    # group(1) is the age in ms
    networks[-1]['last_seen'] = int(result.group(1))

def handle_unknown(line, result, networks):
    # group(1) is the key, group(2) is the rest of the line
    networks[-1][result.group(1)] = result.group(2)

class WiFiManager:
    def __init__(self):
        self._scanInterfaces = [ ]

    def checkIsWireless(self, req):
        return req.device and req.device[0] == 'w' # TODO

    def startScan(self, req):
        if req.interface not in self._scanInterfaces:
            self._scanInterfaces.append(req.interface)

    def endScan(self, req):
        if req.interface in self._scanInterfaces:
            self._scanInterfaces.remove(req.interface)

    def getInterfaces(self):
        return self._scanInterfaces

    @staticmethod
    def getScan(interface):
        scanStart = rospy.Time.now()
        proc = subprocess.Popen(['iw', 'dev', interface, 'scan'], stdout=subprocess.PIPE)
        stdout, stderr =  proc.communicate()
        scanDuration = (rospy.Time.now() - scanStart).to_sec()

        lines = stdout.decode('utf-8').split('\n')

        networks = []
        matchers = []

        # catch the line 'BSS XX:YY:ZZ:AA:BB:CC(on wlan0)'
        matchers.append(line_matcher(r'^BSS (([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2}))', handle_new_network))

        # catch the line 'SSID: network name'
        matchers.append(line_matcher(r'\s+SSID: (.+)', handle_ssid))

        # catch the line 'freq: 2412'
        matchers.append(line_matcher(r'\s+freq: (\d+)', handle_freq))

        # catch the line 'signal: -71.00 dBm'
        matchers.append(line_matcher(r'\s+signal: -([^ ]+) dBm', handle_signal))

        # catch the line 'signal: -71.00 dBm'
        matchers.append(line_matcher(r'\s+last seen: (\d+) ms ago', handle_last_seen))

        # catch any other line that looks like this:
        # Key:value
        matchers.append(line_matcher(r'\s+([^:]+): (.+)', handle_unknown))

        # read each line of output, testing against the matches above
        # in that order (so that the key:value matcher will be tried last)
        for line in lines:
            for m in matchers:
                result = m.regexp.match(line)
                if result:
                    m.handler(line, result, networks)
                    break

        if networks:
            scanMsg = WiFiScanData()
            scanMsg.header.stamp = rospy.Time.now()
            scanMsg.interface = interface
            scanMsg.scan_duration = scanDuration

            for network in networks:
                stationMsg = WiFiStationData()
                stationMsg.mac_address = network['Address']
                stationMsg.ssid = network['SSID']
                stationMsg.channel = network['channel']
                stationMsg.dbm = network['signal']
                stationMsg.age_ms = network['last_seen']
                scanMsg.stations.append(stationMsg)

            return scanMsg

        return None

def main():
    rospy.init_node(NODE_NAME, log_level=rospy.DEBUG)

    wifiManager = WiFiManager()

    services = [
        rospy.Service(WIFI_SERVICE, CheckIsWireless, wifiManager.checkIsWireless),
        rospy.Service(START_SCAN_SERVICE, StartScan, wifiManager.startScan),
        rospy.Service(END_SCAN_SERVICE, EndScan, wifiManager.endScan)
    ]

    pub = rospy.Publisher(TOPIC_NAME, WiFiScanData, queue_size=1)

    while not rospy.is_shutdown():
        for interface in wifiManager.getInterfaces():
            msg = WiFiManager.getScan(interface)
            if msg:
                pub.publish(msg)

if __name__ == '__main__':
    main()
